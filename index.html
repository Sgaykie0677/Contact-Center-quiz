<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Contact Center Playbook Quiz</title>
<style>
  /* Basic Page Styling */
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background: #f6f7fb; color: #333; }
  .container { max-width: 800px; margin: 40px auto; padding: 0 20px; }
  
  /* Card Styling */
  .card { background: #fff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); padding: 24px; margin-bottom: 20px; }
  
  /* Typography */
  h1 { font-size: 24px; margin-bottom: 16px; color: #0a66c2; }
  h2 { font-size: 18px; margin-bottom: 12px; }
  
  /* Form Elements */
  select, button { padding: 10px 16px; border-radius: 8px; border: 1px solid #ddd; font-size: 14px; cursor: pointer; }
  select { margin-right: 10px; }
  button.primary { background: #0a66c2; color: #fff; border: none; font-weight: 600; }
  button.primary:hover { background: #004182; }
  
  /* Quiz Layout */
  .question-title { font-weight: 700; font-size: 16px; margin-bottom: 12px; }
  .options label { display: block; padding: 8px 12px; border: 1px solid #eee; border-radius: 6px; margin-bottom: 8px; cursor: pointer; transition: background 0.2s; }
  .options label:hover { background: #f0f7ff; }
  .options input { margin-right: 10px; }

  /* FEEDBACK SECTION (Restructured per your request) */
  .feedback-box { 
    margin-top: 20px; 
    padding: 16px; 
    background: #f9fafb; 
    border-left: 5px solid #ccc; 
    border-radius: 4px;
  }
  .feedback-box.correct { border-left-color: #108a00; background: #e6f4e6; }
  .feedback-box.incorrect { border-left-color: #d93025; background: #fce8e6; }
  
  .feedback-item { margin-bottom: 8px; font-size: 14px; line-height: 1.5; }
  .feedback-label { font-weight: 700; margin-right: 5px; }
  
  /* Utility */
  .hidden { display: none; }
</style>
</head>
<body>

<div class="container">
  <h1>Contact Center Playbook Quiz</h1>
  
  <div class="card" id="setupCard">
    <label for="sectionSelect"><strong>Choose a topic:</strong></label><br><br>
    <select id="sectionSelect"></select>
    <button class="primary" onclick="startQuiz()">Start Quiz</button>
  </div>

  <div class="card hidden" id="quizCard">
    <div id="quizContainer"></div>
    
    <div style="margin-top: 20px;">
      <button class="primary" id="submitBtn" onclick="submitAnswer()">Submit Answer</button>
      <button class="primary hidden" id="nextBtn" onclick="nextQuestion()">Next Question</button>
    </div>
    
    <div id="finalScore" class="hidden" style="margin-top:20px; font-weight:bold; font-size:18px;"></div>
  </div>
</div>

<script>
// --- 1. DATA STRUCTURE ---
// Defined terms from your PDF [cite: 869-880]
const DEFINITIONS = {
  "Eligibility": "Verification that the caller is an active member with valid coverage.",
  "MHK": "System used to track Clinical Review workflows and documentation.",
  "R15": "Reject code for missing prior authorization.",
  "Documentation": "Recording actions, outcomes, and rationale in a structured, audit-ready format.",
  "Escalation": "Routing a call or case to a higher authority per protocol.",
  "R05": "Reject code applied when duplicate submissions are identified." // Added based on context
};

// Quiz Content organized by section [cite: 887-903]
const QUESTIONS = [
  // Member Verification
  {
    section: "Member Verification & Eligibility",
    q: "What is the first step when handling a Clinical Review call?",
    options: ["Verify member identity", "Check escalation protocol", "Document reject code", "Transfer to supervisor"],
    correctIndex: 0,
    explanation: "Always verify member identity first.",
    term: "Eligibility",
    playbookLang: "Per playbook: 'Begin every call by verifying the member's identity using two approved identifiers.'"
  },
  {
    section: "Member Verification & Eligibility",
    q: "If a caller refuses to verify their identity, what is the correct action?",
    options: ["End call politely", "Proceed with call", "Escalate to manager", "Assign R20 reject code"],
    correctIndex: 0,
    explanation: "Member information (PHI) cannot be released without proper HIPAA Verification.",
    term: "Eligibility",
    playbookLang: "Per playbook: 'End call if caller refuses verification.'"
  },
  // Clinical Review
  {
    section: "Clinical Review Workflow",
    q: "Which system is used to track Clinical Review workflows?",
    options: ["MHK", "Email", "Excel Spreadsheet", "Teams Chat"],
    correctIndex: 0,
    explanation: "MHK is the designated system for tracking all clinical workflows.",
    term: "MHK",
    playbookLang: "Per playbook: 'Track workflows in MHK.'"
  },
  {
    section: "Clinical Review Workflow",
    q: "What is the final step before closing a clinical review?",
    options: ["Confirm resolution", "Assign reject code", "Escalate ticket", "Delete draft notes"],
    correctIndex: 0,
    explanation: "You must confirm the resolution ensures the issue is fully addressed.",
    term: "Documentation",
    playbookLang: "Per playbook: 'Confirm resolution before closing.'"
  },
  // Reject Codes
  {
    section: "Reject Codes",
    q: "Which reject code applies when prior authorization is missing?",
    options: ["R01", "R15", "R22", "R99"],
    correctIndex: 1, // R15 is index 1
    explanation: "R15 is the specific code for missing PAs.",
    term: "R15",
    playbookLang: "Per playbook: 'Use reject code R15 when prior authorization is not on file.'"
  },
  {
    section: "Reject Codes",
    q: "Which reject code is used for a duplicate submission?",
    options: ["R05", "R15", "R22", "R99"],
    correctIndex: 0, 
    explanation: "R05 denotes a duplicate request.",
    term: "R05",
    playbookLang: "Per playbook: 'Apply R05 when duplicate submissions are identified.'"
  },
  // Documentation
  {
    section: "Documentation Standards",
    q: "How should audit-ready notes be formatted?",
    options: ["Chronological, specific, and policy-aligned", "Vague and brief", "Copied from prior cases", "Stored outside the system"],
    correctIndex: 0,
    explanation: "Notes must be detailed and ordered correctly to survive an audit.",
    term: "Documentation",
    playbookLang: "Per playbook: 'Notes must be chronological, specific, and aligned to policy for audit readiness.'"
  },
  {
    section: "Documentation Standards",
    q: "What must be documented after applying a reject code?",
    options: ["Supervisor initials", "Reason and action taken", "Caller's tone", "Nothing"],
    correctIndex: 1,
    explanation: "Documentation must justify the code usage and the outcome.",
    term: "Documentation",
    playbookLang: "Per playbook: 'Document the reason for the reject code and the action taken to resolve.'"
  }
];

// --- 2. APP STATE ---
let currentSectionData = [];
let currentIndex = 0;
let score = 0;

// --- 3. INITIALIZATION ---
const sectionSelect = document.getElementById("sectionSelect");
// Get unique sections
const uniqueSections = [...new Set(QUESTIONS.map(item => item.section))];
uniqueSections.forEach(section => {
  const opt = document.createElement("option");
  opt.value = section;
  opt.textContent = section;
  sectionSelect.appendChild(opt);
});

// --- 4. FUNCTIONS ---

function startQuiz() {
  const selectedSection = sectionSelect.value;
  currentSectionData = QUESTIONS.filter(q => q.section === selectedSection);
  currentIndex = 0;
  score = 0;
  
  document.getElementById("setupCard").classList.add("hidden");
  document.getElementById("quizCard").classList.remove("hidden");
  document.getElementById("finalScore").classList.add("hidden");
  
  showQuestion();
}

function showQuestion() {
  // Reset UI
  document.getElementById("submitBtn").classList.remove("hidden");
  document.getElementById("nextBtn").classList.add("hidden");
  const container = document.getElementById("quizContainer");
  container.innerHTML = "";
  
  if (currentIndex >= currentSectionData.length) {
    finishQuiz();
    return;
  }

  const qData = currentSectionData[currentIndex];
  
  // Render Title
  const title = document.createElement("div");
  title.className = "question-title";
  title.textContent = `${currentIndex + 1}. ${qData.q}`;
  container.appendChild(title);
  
  // Render Options
  const optionsDiv = document.createElement("div");
  optionsDiv.className = "options";
  qData.options.forEach((opt, idx) => {
    const label = document.createElement("label");
    label.innerHTML = `<input type="radio" name="questionOption" value="${idx}"> ${opt}`;
    optionsDiv.appendChild(label);
  });
  container.appendChild(optionsDiv);
  
  // Placeholder for feedback
  const feedbackDiv = document.createElement("div");
  feedbackDiv.id = "feedbackArea";
  container.appendChild(feedbackDiv);
}

function submitAnswer() {
  const qData = currentSectionData[currentIndex];
  const selectedEl = document.querySelector('input[name="questionOption"]:checked');
  
  if (!selectedEl) {
    alert("Please select an answer.");
    return;
  }
  
  const selectedIndex = parseInt(selectedEl.value);
  const isCorrect = (selectedIndex === qData.correctIndex);
  
  if (isCorrect) score++;

  // --- 5. RESTRUCTURED FEEDBACK GENERATION ---
  // This section creates the exact format you requested
  
  const feedbackArea = document.getElementById("feedbackArea");
  const definitionText = DEFINITIONS[qData.term] || "Definition not available.";
  const correctActionText = qData.options[qData.correctIndex]; // The text of the correct answer
  
  // HTML Template for the 4 key items
  feedbackArea.innerHTML = `
    <div class="feedback-box ${isCorrect ? 'correct' : 'incorrect'}">
      
      <div class="feedback-item">
        <span class="feedback-label">‚úÖ Correct/Incorrect status:</span>
        ${isCorrect ? '<strong>Correct!</strong>' : '<strong>Incorrect.</strong>'} 
        (Correct Action: ${correctActionText})
      </div>

      <div class="feedback-item">
        <span class="feedback-label">üìò Explanation:</span>
        ${qData.explanation}
      </div>

      <div class="feedback-item">
        <span class="feedback-label">üìñ Definition of the key term:</span>
        <strong>${qData.term}:</strong> ${definitionText}
      </div>

      <div class="feedback-item">
        <span class="feedback-label">üó£Ô∏è Playbook Language:</span>
        <em>"${qData.playbookLang}"</em>
      </div>

    </div>
  `;
  
  // Toggle buttons
  document.getElementById("submitBtn").classList.add("hidden");
  document.getElementById("nextBtn").classList.remove("hidden");
  
  // Disable radio buttons so they can't change answer
  const radios = document.querySelectorAll('input[name="questionOption"]');
  radios.forEach(r => r.disabled = true);
}

function nextQuestion() {
  currentIndex++;
  showQuestion();
}

function finishQuiz() {
  const container = document.getElementById("quizContainer");
  container.innerHTML = "<h2>Quiz Complete!</h2>";
  document.getElementById("submitBtn").classList.add("hidden");
  document.getElementById("nextBtn").classList.add("hidden");
  
  const finalScoreDiv = document.getElementById("finalScore");
  finalScoreDiv.classList.remove("hidden");
  finalScoreDiv.textContent = `Final Score: ${score} / ${currentSectionData.length}`;
  
  // Add a restart button
  const restartBtn = document.createElement("button");
  restartBtn.className = "primary";
  restartBtn.textContent = "Take Another Quiz";
  restartBtn.onclick = () => { location.reload(); };
  container.appendChild(restartBtn);
}
</script>

</body>
</html>
